function D3_Formatter(){}


/**
 * Transforme le json generique en json compris par d3js pour la representation "graph"
 * @param json : graph -> JSON generique a transformer
 * @return json : graph -> JSON generique bien forme
 */
D3_Formatter.prototype.to_graph = function(graph){

	// Get Nodes
	var nodeArray = [];
	var typeColor = {};
	var i = 0;
	graph.noeuds.forEach(
		function(node) { 
			node.name = node.nom;
			
			// Nous n'avons plus besoin de nom
			delete node.nom;
			
			if(typeColor[node.type] == null){
				typeColor[node.type] = i;
				i++;
			}
			node.group = typeColor[node.type];
			
			// On construit un tableau de noeud afin d'avoir leur position
			// pour pouvoir creer les links du graphe
			nodeArray.push(node.id);
		}
	);
	
	graph.nodes = graph.noeuds;
	
	// On met des couleurs pour chaque relation
	var colorLink = {};
	// On definit une value de type int pour d3js
	// La premiere relation ayant une value de 1, la seconde de 2, ...
	var value = 1;
	graph.relations.forEach(
		function(relation){
			colorLink[relation] = value;
			value++;
		}
	);

	// Get Links
	graph.links = [];
	
	// Get Connexion
	graph.relationsUsed = [];
	
	// Parcours des graphes du json
	graph.graphe.forEach(
		function(graphe) {
		
			// La source est l'element noeud du graphe
			source = graphe.noeud;
			
			// Si la source est bien definie dans la liste des noeuds
			if(nodeArray.indexOf(source) != -1){
				
				// Parcours de l'ensemble des relations, pour avoir leur nom
				graph.relations.forEach(
					function(relation) {
					
						// Si le graphe a la relation
						if(graphe[relation]){
							// On parcourt l'ensemble des targets de la relation
							graphe[relation].forEach(
								function(target) {
									nameRelation = [];
									// Si la target est bien definie dans la liste des noeuds
									if(nodeArray.indexOf(target) != -1){
										for(var i = 0; i < graph.links.length; i++) {
											if (graph.links[i].source == nodeArray.indexOf(target) 
												&& graph.links[i].target == nodeArray.indexOf(source)) {
												nameRelation.push(relation);
												graph.links[i].name.push(relation);
											}
										}
										if(nameRelation.length  == 0){
											nameRelation.push(relation);
											// On ajoute un link bien formate au tableau links du graphe
											graph.links.push({
												source: nodeArray.indexOf(source),
												target: nodeArray.indexOf(target),
												value: colorLink[relation],
												name: nameRelation
											});
										}
									}
								}
							);
							// On insere les relations correspondantes dans les deux sens
							if(graph.relationsUsed.indexOf(relation) == -1){
								graph.relationsUsed.push(relation);
							}
						}
						
						// On incremente la value afin d'avoir des valeurs differentes pour chaque relation
						value++;
					}
				);
			}
		}
	);
	// On supprime du json ce dont nous avons plus besoins
	delete graph.noeuds;
	delete graph.relations;
	delete graph.graphe;

	return graph;
}

/**
 * Transforme le json generique en json compris par d3js pour la representation "tree"
 * @param json : graph -> JSON generique a transformer
 * @return json : graph -> JSON generique bien forme
 */
D3_Formatter.prototype.to_tree = function(jsongenerique)
{
	var d3_tree = {};

	//Tableau vu pour le parcours en largeur
	var vu = {};
	//Tableau nodes pour la liste des noeuds présents dans d3_tree
	var nodes = {};
	//Tableau noms pour enregistrer le nom correspondant à l'id
	var noms = {};
	//Tableau descriptions pour enregistrer la description correspondant à l'id
	var descriptions = {};
	//Tableau types pour enregistrer la description correspondant à l'id
	var types = {};
	//Tableau couleur pour enregistrer la description correspondant à l'id
	var typecouleurs = {};
	var nbcouleur = 0;

	var nbrel = 0;
	var relcouleurs = {};
	jsongenerique.relations.forEach(
		function(relation) { relcouleurs[relation] = nbrel++; }
	);

	//On initialise vu à faux
	jsongenerique.noeuds.forEach(
		function(node) { 
			vu[node.id] = false;
			types[node.id] = node.type;
			if (node.description) {
				noms[node.id] = node.nom;
				descriptions[node.id] = node.description;
			}
			else
			{
				if (node.nom.length > 10) {
					noms[node.id] = node.nom.substring(0,10) + '...';
					descriptions[node.id] = node.nom;
				}
				else {
					noms[node.id] = node.nom;
					descriptions[node.id] = node.nom;
				}
			}
			if (!typecouleurs[node.type]) { typecouleurs[node.type] = nbcouleur++; }
		}
	);

	var enfants = [];
	var relations = {};
	//Pour chaque noeud on va aller chercher ses enfants directs
	jsongenerique.graphe.forEach(
		function(data) {
			enfants[data.noeud] = [];
			relations[data.noeud] = {};
			jsongenerique.relations.forEach( //Ses enfants sont organisés par relation
				function(relation) {
					if (data[relation]) { data[relation].forEach(
						function(enfant) {
							enfants[data.noeud].push(enfant);
							relations[data.noeud][enfant] = relation;
						}
					);}
				}
			);
		}
	);

	//d3_tree.name = jsongenerique.noeuds[0].nom;
	d3_tree = D3_Formatter.sousarbre(jsongenerique.noeuds[0].id,enfants,vu,noms,descriptions,types,typecouleurs);
	d3_tree.relations = relations;
	d3_tree.relcouleurs = relcouleurs;

	return d3_tree;
}

D3_Formatter.sousarbre = function(parent_id,enfants,vu,noms,descriptions,types,typecouleurs)
{
	var s;
	vu[parent_id] = true;
	var arbre = {};
	arbre.name = noms[parent_id];
	arbre.id = parent_id;
	arbre.description = descriptions[parent_id];
	arbre.type = types[parent_id];
	arbre.size = 1000;
	arbre.typecouleur = typecouleurs[types[parent_id]];
	arbre.children = [];
	enfants[parent_id].forEach(
		function(enfant_id) {
			if (!vu[enfant_id]) {
				s = D3_Formatter.sousarbre(enfant_id,enfants,vu,noms,descriptions,types,typecouleurs);
				if (s.name) {
					arbre.children.push(s);
				}
			}
		}
	);
	return arbre;
}

D3_Formatter.getNode = function(tree, id){
	if(tree.uid == id){
		return tree;
	}
	else {
		for(var i = 0; i < tree.children.length; i++){
			var node = D3_Formatter.getNode(tree.children[i], id);
			if(node){
				return node;
			}
		}
	}
};



{% block vue %}{% endblock %}
